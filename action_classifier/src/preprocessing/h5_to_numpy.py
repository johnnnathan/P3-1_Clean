import os
import numpy as np
import torch
import cv2
import mediapipe as mp

#h5 to numpy converter generated by OpenAI's chatgpt
#Matplotlib requires numpy>=1.23

import argparse

parser = argparse.ArgumentParser(description="Convert v2e event data to skeleton numpy files")
parser.add_argument(
    "--ev2_root",
    type=str,
    required=True,
    help="Path to EV2 directory (e.g. .../EH36M/EV2)"
)
args = parser.parse_args()

EV2_ROOT = args.ev2_root
ALLOWED_ACTIONS = [
    "Directions", "Discussion", "Greeting", "Phoning",
    "Posing", "Sitting", "SittingDown",
    "Waiting", "Walking", "WalkTogether"
]
NUM_BINS = 243
H, W = 480, 640
MAX_EVENTS_PER_BIN = 50000
SMOOTH_K = 7
MIN_DET_CONF = 0.3
MIN_TRACK_CONF = 0.3
MODEL_COMPLEXITY = 1
USE_3CH = True
DENSITY_GAMMA = 0.4
BLUR_KSIZE = 5
OUT_POSE_DIR = os.path.join(os.path.dirname(__file__), "pose_npys")
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

if not hasattr(mp, "solutions"):
    raise RuntimeError(
        "Your mediapipe package doesn't expose 'mediapipe.solutions'. "
        "Try: pip uninstall mediapipe -y && pip install mediapipe==0.10.14"
    )

mp_pose = mp.solutions.pose
pose_est = mp_pose.Pose(
    static_image_mode=True,
    model_complexity=MODEL_COMPLEXITY,
    enable_segmentation=False,
    min_detection_confidence=MIN_DET_CONF,
    min_tracking_confidence=MIN_TRACK_CONF,
)


def find_h5_file(seq_dir: str) -> str:
    h5_dir = os.path.join(seq_dir, "h5")
    if not os.path.isdir(h5_dir):
        raise RuntimeError(f"No 'h5' folder found in: {seq_dir}")
    candidates = [f for f in os.listdir(h5_dir) if f.endswith(".h5")]
    if not candidates:
        raise RuntimeError(f"No .h5 file found in: {h5_dir}")
    if "data.h5" in candidates:
        return os.path.join(h5_dir, "data.h5")
    return os.path.join(h5_dir, sorted(candidates)[0])


def load_events_from_h5(h5_path: str) -> np.ndarray:
    import h5py
    with h5py.File(h5_path, "r") as f:
        if "events" in f:
            ev = np.array(f["events"], dtype=np.float32)
            if ev.ndim != 2 or ev.shape[1] < 4:
                raise RuntimeError(f"Unexpected f['events'] shape: {ev.shape}")

            col0 = ev[:, 0]
            col2 = ev[:, 2]
            if np.nanmax(col0) > 10.0 and np.nanmax(col0) > np.nanmax(col2):
                t = ev[:, 0]; x = ev[:, 1]; y = ev[:, 2]; p = ev[:, 3]
            else:
                x = ev[:, 0]; y = ev[:, 1]; t = ev[:, 2]; p = ev[:, 3]

            return np.stack([x, y, t, p], axis=1).astype(np.float32)

        def pick(name_list):
            for n in name_list:
                if n in f:
                    return np.array(f[n], dtype=np.float32)
            return None

        ts = pick(["ts", "t", "timestamp", "time"])
        x = pick(["x"])
        y = pick(["y"])
        pol = pick(["pol", "p", "polarity"])

        if ts is None or x is None or y is None or pol is None:
            raise RuntimeError(f"Could not find required datasets in h5. Found keys: {list(f.keys())}")

        n = min(len(ts), len(x), len(y), len(pol))
        return np.stack([x[:n], y[:n], ts[:n], pol[:n]], axis=1).astype(np.float32)


# ---------- time binning ----------
def split_events_by_time(events_np: np.ndarray, num_bins: int = 243):
    t = events_np[:, 2]
    t0 = float(np.min(t))
    t1 = float(np.max(t))
    eps = 1e-6
    dt = (t1 - t0 + eps) / num_bins

    bins = []
    for i in range(num_bins):
        a = t0 + i * dt
        b = a + dt
        mask = (t >= a) & (t < b)
        bins.append(events_np[mask])
    return bins


# ---------- events -> image ----------
def _normalize_u8(img: np.ndarray) -> np.ndarray:
    if img.size == 0:
        return img.astype(np.uint8)
    mn = float(np.min(img))
    mx = float(np.max(img))
    if mx <= mn:
        return np.zeros_like(img, dtype=np.uint8)
    x = (img - mn) / (mx - mn)
    x = np.clip(x, 0.0, 1.0)
    return (x * 255.0).astype(np.uint8)


def events_bin_to_frame(ev_bin: np.ndarray, H=480, W=640) -> np.ndarray:
    if ev_bin is None or ev_bin.size == 0:
        return np.zeros((H, W, 3), dtype=np.uint8) if USE_3CH else np.zeros((H, W), dtype=np.uint8)

    if ev_bin.shape[0] > MAX_EVENTS_PER_BIN:
        ev_bin = ev_bin[:MAX_EVENTS_PER_BIN]

    x = np.clip(ev_bin[:, 0].astype(np.int32), 0, W - 1)
    y = np.clip(ev_bin[:, 1].astype(np.int32), 0, H - 1)
    p = ev_bin[:, 3].astype(np.float32)
    p = np.where(p > 0, 1.0, -1.0).astype(np.float32)

    if not USE_3CH:
        img = np.zeros((H, W), dtype=np.float32)
        np.add.at(img, (y, x), p)
        m = np.max(np.abs(img))
        if m > 0:
            img = img / m
        img = (img + 1.0) * 127.5
        img = np.clip(img, 0, 255).astype(np.uint8)
        if BLUR_KSIZE and BLUR_KSIZE >= 3:
            img = cv2.GaussianBlur(img, (BLUR_KSIZE, BLUR_KSIZE), 0)
        return img

    pos = np.zeros((H, W), dtype=np.float32)
    neg = np.zeros((H, W), dtype=np.float32)
    den = np.zeros((H, W), dtype=np.float32)

    pos_mask = p > 0
    neg_mask = ~pos_mask

    if np.any(pos_mask):
        np.add.at(pos, (y[pos_mask], x[pos_mask]), 1.0)
    if np.any(neg_mask):
        np.add.at(neg, (y[neg_mask], x[neg_mask]), 1.0)
    np.add.at(den, (y, x), 1.0)

    den = np.power(den, DENSITY_GAMMA)

    pos_u8 = _normalize_u8(pos)
    neg_u8 = _normalize_u8(neg)
    den_u8 = _normalize_u8(den)

    if BLUR_KSIZE and BLUR_KSIZE >= 3:
        pos_u8 = cv2.GaussianBlur(pos_u8, (BLUR_KSIZE, BLUR_KSIZE), 0)
        neg_u8 = cv2.GaussianBlur(neg_u8, (BLUR_KSIZE, BLUR_KSIZE), 0)
        den_u8 = cv2.GaussianBlur(den_u8, (BLUR_KSIZE, BLUR_KSIZE), 0)

    rgb = np.stack([den_u8, pos_u8, neg_u8], axis=-1)
    return rgb


# ---------- mediapipe ----------
def mediapipe_pose_33(frame_u8: np.ndarray, H: int, W: int):
    if frame_u8.ndim == 2:
        rgb = cv2.cvtColor(frame_u8, cv2.COLOR_GRAY2RGB)
    else:
        rgb = frame_u8

    res = pose_est.process(rgb)
    if not res.pose_landmarks:
        return None

    pts = []
    for lm in res.pose_landmarks.landmark:
        pts.append([lm.x * W, lm.y * H])
    return np.array(pts, dtype=np.float32)


def mp33_to_h36m17(mp33: np.ndarray) -> np.ndarray:
    NOSE = 0
    L_SHO, R_SHO = 11, 12
    L_ELB, R_ELB = 13, 14
    L_WRI, R_WRI = 15, 16
    L_HIP, R_HIP = 23, 24
    L_KNE, R_KNE = 25, 26
    L_ANK, R_ANK = 27, 28

    lhip = mp33[L_HIP]; rhip = mp33[R_HIP]
    lsho = mp33[L_SHO]; rsho = mp33[R_SHO]

    hip = 0.5 * (lhip + rhip)
    neck = 0.5 * (lsho + rsho)
    spine = 0.5 * (hip + neck)
    head = neck + 0.6 * (mp33[NOSE] - neck)

    out = np.zeros((17, 2), dtype=np.float32)
    out[0]  = hip
    out[1]  = mp33[R_HIP]
    out[2]  = mp33[R_KNE]
    out[3]  = mp33[R_ANK]
    out[4]  = mp33[L_HIP]
    out[5]  = mp33[L_KNE]
    out[6]  = mp33[L_ANK]
    out[7]  = spine
    out[8]  = neck
    out[9]  = mp33[NOSE]
    out[10] = head
    out[11] = mp33[L_SHO]
    out[12] = mp33[L_ELB]
    out[13] = mp33[L_WRI]
    out[14] = mp33[R_SHO]
    out[15] = mp33[R_ELB]
    out[16] = mp33[R_WRI]
    return out


# ---------- fill missing ----------
def interpolate_missing(seq):
    T = len(seq)
    out = [None] * T
    valid = [i for i, p in enumerate(seq) if p is not None]
    if len(valid) == 0:
        return np.zeros((T, 17, 2), dtype=np.float32)

    first = valid[0]
    for i in range(0, first):
        out[i] = seq[first].copy()

    last = valid[-1]
    for i in range(last, T):
        out[i] = seq[last].copy()

    for a, b in zip(valid[:-1], valid[1:]):
        pa = seq[a]; pb = seq[b]
        out[a] = pa.copy()
        gap = b - a
        for k in range(1, gap):
            t = k / gap
            out[a + k] = (1.0 - t) * pa + t * pb

    return np.stack(out, axis=0).astype(np.float32)


def smooth_seq(x: np.ndarray, k: int = 7) -> np.ndarray:
    if k is None or k <= 1:
        return x
    if k % 2 == 0:
        k += 1
    pad = k // 2
    y = x.copy()
    T = x.shape[0]
    for t in range(T):
        a = max(0, t - pad)
        b = min(T, t + pad + 1)
        y[t] = x[a:b].mean(axis=0)
    return y


# ---------- helpers ----------
def iter_allowed_sequences(ev2_root: str):
    """
    Yields (seq_dir, action_name, seq_name) for folders matching:
      cam*_S*_<Action>*
    """
    for name in os.listdir(ev2_root):
        seq_dir = os.path.join(ev2_root, name)
        if not os.path.isdir(seq_dir):
            continue

        matched_action = None
        for act in ALLOWED_ACTIONS:
            if f"_{act}" in name:
                matched_action = act
                break
        if matched_action is None:
            continue

        h5_dir = os.path.join(seq_dir, "h5")
        if not os.path.isdir(h5_dir):
            continue

        yield seq_dir, matched_action, name


def process_one_sequence(seq_dir: str) -> np.ndarray:
    h5_path = find_h5_file(seq_dir)
    events = load_events_from_h5(h5_path)
    events = events[np.argsort(events[:, 2])]

    bins = split_events_by_time(events, num_bins=NUM_BINS)

    pose_seq_list = []
    for b in bins:
        frame = events_bin_to_frame(b, H=H, W=W)
        mp33 = mediapipe_pose_33(frame, H=H, W=W)
        if mp33 is None:
            pose_seq_list.append(None)
        else:
            pose_seq_list.append(mp33_to_h36m17(mp33))

    pose_seq_17 = interpolate_missing(pose_seq_list)
    pose_seq_17 = smooth_seq(pose_seq_17, k=SMOOTH_K)
    return pose_seq_17


def main():
    os.makedirs(OUT_POSE_DIR, exist_ok=True)

    seqs = list(iter_allowed_sequences(EV2_ROOT))
    print("Found sequences:", len(seqs))
    if not seqs:
        print("Nothing found. Check EV2_ROOT and folder naming.")
        return

    for idx, (seq_dir, action, seq_name) in enumerate(seqs, 1):
        try:
            print(f"\n[{idx}/{len(seqs)}] {seq_name}  (action={action})")
            pose_seq_17 = process_one_sequence(seq_dir)
            out_dir = os.path.join(OUT_POSE_DIR, action)
            os.makedirs(out_dir, exist_ok=True)

            out_npy = os.path.join(out_dir, f"{seq_name}_pose17.npy")
            np.save(out_npy, pose_seq_17)
            print("Saved:", out_npy, "| shape:", pose_seq_17.shape)

        except Exception as e:
            print("FAILED:", seq_name, "->", repr(e))


if __name__ == "__main__":
    main()
